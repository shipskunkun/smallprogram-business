



## 8-1 异步函数return

1. 封装请求两步：  
	+ 需要封装 http 这个类，发送http 请求， 封装了 wx.request 方法，那么是用回调函数还是promise，根据需求定
	+ 我们需要对项目所有的请求，封装成类方法，如果需要用的时候，就import该文件，使用文件的某个方法


异步请求不能通过  let  a =  class.getLateset()  接受函数调用结果  
异步函数没有 return,  
如果有，只能通过 promise, 我们先介绍通过回调函数处理结果这种方式

```
// 因为是异步函数，所以return不到真实结果的 res, 所以无法return 
success: (res)=> {}
return res 
```

如果需要，我们需要使用回调函数，调用异步请求结果,     

```
scallBack(res)
```

### Q: 回调和promise

分析两种封装的http和分布调用

第一种：需要我们在调用时候，传入success函数

```
//  params.success && 作用：有的请求没有callback 函数，如点赞

class HTTP {
	request（params）{
		wx.request({
			 url:
			 method:
			 data:
			 success:(res)=>{
			    let code = res.statusCode.toString()
			    if (code.startsWith('2')){
			        params.success && params.success(res.data)
			    }
			},
			fail:(err) {}
		})
	}
}
export {HTTP}

http.request({
	url:
	success((res)=>{
	
	})
})

```

第二种使用promise

```
//返回的是promise 实例对象
request({url,data={},method='GET'}){
    return new Promise((resolve, reject)=>{
        this._request(url,resolve,reject,data, method)
    })
}

调用：
a() {
	return this.request({})
}


a().then(res => {}
)
```



## 8-2  给组件传值

通过给子组件的 properties 传递父组件的值

	properties: {
		count: {
			type: Number
		}
	}  

	

但是data 中不行

	
	// 注意是 " ", 代表引号中的是表达式
	<v-like count="{{ data.count }}"></v-like>
	


调试技巧：

	打开小程序控制台，看到appData 可以看到组件数据




## 8-3 setData 的误区

setData 只做数据更新， 只可以通过setData 做数据更新  
数组定义需要在 data 对象中设置

```
this.setData({
	key: value
})

// 不能这种写法
this.data.key = data; 

```
在setData 中设置的key 可以自动的在data 中注册，从而在 xml 文件中，很好的通过
{{}} 使用，但是最好先在 data 中设置相应的值， 

```
data: {
	name: null
}
``` 





## 8-5 movie 组件编写

#### Q:如何让撑不满的<text>中字体居中显示？当父元素设置flex，居中显示时
	
	如果设置width, 当text 文本不够一行时候，块虽然居中，但是块中的文字不居中
	此时需要：去掉width，改为设置最大宽度即可
	
	.classic-container {
	    display: flex;
	    flex-direction: column;
	    align-items: center;
	    .content{
		   font-size:36rpx;
		   max-width: 550rpx;
		 }
	  }



## 8-7 点赞还是取消
	
	需要知道，当前状态是什么？是被点赞了，还是灰色了？
	
子组件触发父组件事件，  
triggerEvent  
参考Vue

event.detail.**

```
this.triggerEvent('like',{
    behavior:behavior,
    //这里可以有很多对象
    lala: lala
  },{})
      
onLike: function (event) {
  const behavior = event.detail.behavior
  likeModel.like(behavior, this.data.classic.id,
    this.data.classic.type)
},
```

	

## 8-8 组件的生命周期

记住一点：组件周期函数钩子中最常用的就是attached的！
 
不是page!!! 是组件，

created: 组件实例进入页面节点树时执行，注意此时不能调用setData  
attached: 组件实例进入页面节点树时执行，  
区别就是一个可以调用setData 一个不能


created	无	在组件实例刚刚被创建时执行	1.6.3   
attached	无	在组件实例进入页面节点树时执行	1.6.3  
ready	无	在组件在视图层布局完成后执行	1.6.3  




## 8-9

小程序会合并  properties 和 data 对象，合并成一个合集

打印出来，是一致的


properties 和 data 中的同名变量，data 中定义的值会被覆盖




## 8-11 observer 函数
 相当于 Vue 中的 watch
 
 
	 properties: {
	 	index: {
	 		type: Number,
	 		// 第三个参数是干嘛的
	 		observer: function(new, old, changePath){
	 		}
	 	}
	 }


### Q: 为什么子组件中修改 接受的值，父组件中没同步
	
	原因： 1. 定义数据类型为Number， 组件自动修改 '08' => 8, observer 得出，
	new 值和 old值一致，没变化, 所以不触发
	
### Q: 不要在observe 中修改自身值，

	
	因为观察你变化=>改变，改变了，
	如果这样直接写：
	
	properties: {
	    index:{
	      type:String,
	      observer:function(newVal, oldVal, changedPath){
	        let val = newVal < 10?'0'+newVal:newVal
	        this.setData({
	          index:val
	        })
	      }
	    }
  	} 
  	
  	



触发observer 再次改变，递归调用 observer 函数， 内存泄露，   
8 => 08, observer 看到改变了， 又调用一次， 小于10 
通过在 data中重新定义值
	
	
	data: {
		_index: 0
	}

	properties: {
	    index:{
	      type:String,
	      observer:function(newVal, oldVal, changedPath){
	        let val = newVal < 10?'0'+newVal:newVal
	        this.setData({
	        //这里看见没，换成了 _index, 如果是 index 本身，循环调用
	          _index:val
	        })
	      }
	    }
  	}
  
  






## 8-14 日期组件
inline-flex 和 inline-block 一样，对内部元素来说是个 display:flex 的容器，对外部元素来说是个 inline 的块。

```
display： inline-flex


//  baseline
.index-container{
  display:flex;
  flex-direction: row;
  align-items: baseline;      
}
```

![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)







